{
    "contents" : "require(mhsmm)\nrequire(mclust)\nrequire(xts)\nrequire(PortfolioAnalytics)\nrequire(PerformanceAnalytics)\nrequire(TTR)\n\n# GMM Training Model \n# using return data as input data, calibrate n-centroids gaussian mixture model\n# and find the most-likely model with the lowerest BIC setup\n# input -\n#     data_training: the training data set (as Data.Frame )\n#     nstate: default = 0. the number of states to specify. If nstate=0, the function will find the \n#             optimal number of nstates. \n# output - gmm model, including \n#     J: (number of centroids)\n#     b: (mean, vcv)\n#     gmm: (gmm model calibrated)\n##########################################################################\ngmm_training <- function(data_training, nstate=0) {\n  output <- list();\n  \n  if (nstate == 0) {\n    mm_model <- Mclust(data_training);\n  }\n  else {\n    mm_model <- Mclust(data_training, G = nstate)\n  }\n  mm_output <- summary(mm_model);\n  \n  ### determine whether training dataset is a single serie or multiples\n  n_serie <- ncol(data_training)  \n  \n  #### creating the HMM model\n  J <- mm_output$G\n  #print(paste(\"Nr of Regimes \", J))\n  initial <- rep(1/J, J)\n  P <- matrix(rep(1/J, J*J), nrow=J)\n  \n  if (n_serie == 1) {\n    mean <- as.numeric(mm_output$mean)\n    vcv <- as.numeric(mm_output$variance)\n  }\n  else\n  {\n    mean <- list()\n    vcv <- list()\n    for (j in 1:J){\n      mean[[j]] <- mm_output$mean[, j]\n      vcv[[j]] <- mm_output$variance[,,j]\n    }\n  }\n  \n \n  b <- list()\n  b$mu <- mean\n  b$sigma <- vcv\n  \n  output$gmm <- mm_model\n  output$b <- b;\n  output$J <- J;\n  output$initial <- initial;\n  output$P <- P;\n  output$mean <- mean;\n  output$vcv <- vcv;\n  return(output);\n}\n\n\n\n# GMM 交易测试工具\n# 这里我们使用GMM做in-the-sample样本内测试。 通过gmm_training方程的帮助， 对测试数据进行分类， \n# 找到最佳的市场状态数，以及各个时间点的市场状态分类。 \n# 最后我们将各个市场状态下的回报曲线计算出来。 \n##########################################################################\ngmm_insample_test <- function(dataset_train, benchmark_train, ret_train) {\n  output <- gmm_training(data_training = dataset_train)\n  print(paste(\"regime = \", output$J))\n  #output$gmm$classification - 每个数据代表的市场状态\n  #output$gmm$pro - 每个市场状态的几率\n  \n  # 根据不同的市场状态排序\n  ranked_regimes <- rank(output$gmm$parameters$mean)\n  ranked_classification <- ranked_regimes[output$gmm$classification]\n  dates <- index(as.xts(output$gmm$classification))\n  regimes <- as.xts(ranked_classification, \n                    order.by=dates)\n  \n  ## 画出图形\n  plot(benchmark_train)\n  points(benchmark_train *  (regimes == 1), pch=20,  col=\"black\")\n  points(benchmark_train * (regimes == 2), pch=20, col=\"green\")\n  points(benchmark_train * (regimes == 3), pch=20, col=\"red\")\n  points(benchmark_train * (regimes == 4), pch=20, col=\"orange\")\n  points(benchmark_train * (regimes == 5), pch=20, col=\"blue\")\n  \n  ## 根据不同市场状态的投资回报\n  ret_regimes <- na.omit(cbind(\n    ret_train * (regimes==1), \n    ret_train *(regimes==2),\n    ret_train * (regimes==3), \n    #data_test1[, 1] * (regimes==4), \n    #data_test1[, 1] * (regimes==5), \n    ret_train))\n  charts.PerformanceSummary(ret_regimes)\n  rbind(table.AnnualizedReturns(ret_regimes), maxDrawdown(ret_regimes), CalmarRatio(ret_regimes))\n  \n  ### 返回不同市场状态下的数据\n  output <- list()\n  output$ret <- ret_regimes\n  return(output)\n}\n\n\n##################################################################################\nhmm_training2 <- function(gmm, data_training) {\n  output <- list();\n  \n  ### determine whether training dataset is a single serie or multiples\n  n_serie <- ncol(data_training)  \n  \n  #### training HMM model\n  if (n_serie == 1) {\n    hmm_model <- hmmspec(init=gmm$initial, trans=gmm$P, parms.emission = gmm$b, dens.emission = dnorm.hsmm)\n    hmm_fitted <- hmmfit(as.numeric(data_training), hmm_model, mstep = mstep.norm)\n  }\n  else {\n    hmm_model <- hmmspec(init=gmm$initial, trans=gmm$P, parms.emission = gmm$b, dens.emission = dmvnorm.hsmm)\n    hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n  }\n  #print(\"hmm fitting\")\n  #### Predict future regime\n  regime <- tail(hmm_fitted$yhat, 1);\n  output$hmm <- hmm_fitted\n  \n  return(output) \n}\n##################################################################################\nhmm_training <- function(gmm, data_training, data_testing = NULL, ret_target) {\n  output <- list();\n  \n  ### determine whether training dataset is a single serie or multiples\n  n_serie <- ncol(data_training)  \n  \n  #### training HMM model\n  if (n_serie == 1) {\n    hmm_model <- hmmspec(init=gmm$initial, trans=gmm$P, parms.emission = gmm$b, dens.emission = dnorm.hsmm)\n    hmm_fitted <- hmmfit(as.numeric(data_training), hmm_model, mstep = mstep.norm)\n  }\n  else {\n    hmm_model <- hmmspec(init=gmm$initial, trans=gmm$P, parms.emission = gmm$b, dens.emission = dmvnorm.hsmm)\n    hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n  }\n  #print(\"hmm fitting\")\n  #### Predict future regime\n  regime <- tail(hmm_fitted$yhat, 1);\n  output$hmm <- hmm_fitted\n  \n  ############################################################\n  #### In the training set, the regimes and returns\n  yhat_train <- as.xts(hmm_fitted$yhat, order.by = index(data_training), tzone=tzone(data_training))\n  ret_training_regime <- list()\n  for (k in 1:gmm$J) {\n    ret_training_regime[[k]] <- ret_target * (yhat_train == k)\n  }\n  ret_training_regime <- do.call(cbind, ret_training_regime)\n  \n  output$hmm_yhat <- yhat_train\n  output$hmm_ret_regime <- ret_training_regime\n  output$hmm_predict_regime <- tail(output$hmm_yhat, 1);\n  \n  print(sum(ret_training_regime))\n  \n  ### calculate the risk measures \n  sharpe_training_regime_vol <- SharpeRatio.annualized(ret_training_regime)[1,]\n  max_sharpe_regime <- match(max(sharpe_training_regime_vol), sharpe_training_regime_vol)\n  #calmar_training_regime <- CalmarRatio(ret_training_regime)\n  #max_calmar_regime <- match(max(calmar_training_regime), calmar_training_regime)\n  #sortino_training_regime <- SortinoRatio(ret_training_regime)\n  #max_sortino_regime <- match(max(sortino_training_regime), sortino_training_regime)\n  #output$hmm_ret_regime_annualized <- Return.annualized(ret_training_regime)\n  \n  print(sharpe_training_regime_vol)\n\n  \n  output$sharpe_ratio <- sharpe_training_regime_vol;\n  output$sharpe_ratio_max_regime <- max_sharpe_regime;\n  #output$calmar_ratio <- calmar_training_regime;\n  #output$calmar_ratio_max_regime <- max_calmar_regime;\n  #output$sortino_ratio <- sortino_training_regime;\n  #output$sortino_ratio_max_regime <- max_sortino_regime;\n  \n  \n  \n  return(output);\n  \n}\n\n\n##################################################################################\nhmm_training1 <- function(gmm, data_training, data_testing = NULL, ret_target) {\n  output <- list();\n  \n  ### determine whether training dataset is a single serie or multiples\n  n_serie <- ncol(data_training)  \n  \n  #### training HMM model\n  if (n_serie == 1) {\n    hmm_model <- hmmspec(init=gmm$initial, trans=gmm$P, parms.emission = gmm$b, dens.emission = dnorm.hsmm)\n    hmm_fitted <- hmmfit(as.numeric(data_training), hmm_model, mstep = mstep.norm)\n  }\n  else {\n    hmm_model <- hmmspec(init=gmm$initial, trans=gmm$P, parms.emission = gmm$b, dens.emission = dmvnorm.hsmm)\n    hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n  }\n  #print(\"hmm fitting\")\n  #### Predict future regime\n  regime <- tail(hmm_fitted$yhat, 1);\n  pred <- predict(hmm_fitted, data_testing)\n  \n  ############################################################\n  #### In the training set, the regimes and returns\n  yhat_train <- as.xts(pred$s, order.by = index(data_testing), tzone=tzone(data_testing))\n  ret_training_regime <- list()\n  for (k in 1:gmm$J) {\n    ret_training_regime[[k]] <- ret_target * (yhat_train == k)\n  }\n  ret_training_regime <- do.call(cbind, ret_training_regime)\n  \n  output$hmm_yhat <- yhat_train\n  output$hmm_ret_regime <- ret_training_regime\n  output$hmm_predict_regime <- tail(output$hmm_yhat, 1);\n  \n  \n  return(output);\n  \n}\n\ngmmhmm_training <- function(data_training) {\n  output <- list();\n  \n  #### Using Mixture Model to determine the optimal number of regimes and the settings under \n  #### each regime\n  mm_model <- Mclust(data_training);\n  mm_output <- summary(mm_model);\n  output$gmm <- mm_model;\n  \n  #### creating the HMM model\n  J <- mm_output$G\n  print(paste(\"Nr of Regimes \", J))\n  initial <- rep(1/J, J)\n  P <- matrix(rep(1/J, J*J), nrow=J)\n  mean <- list()\n  vcv <- list()\n  for (j in 1:J){\n    mean[[j]] <- mm_output$mean[, j]\n    vcv[[j]] <- mm_output$variance[,,j]\n  }\n  b <- list()\n  b$mu <- mean\n  b$sigma <- vcv\n  \n  #### training HMM model\n  hmm_model <- hmmspec(init=initial, trans=P, parms.emission = b, dens.emission =dmvnorm.hsmm)\n  hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n  print(\"hmm fitting\")\n  #### Predict future regime\n  regime <- tail(hmm_fitted$yhat, 1);\n  \n  output$hmm <- hmm_fitted\n  \n  ############################################################\n  #### In the training set, the regimes and returns\n  yhat_train <- as.xts(hmm_fitted$yhat, order.by = index(data_training), tzone=tzone(data_training))\n  ret_training_regime <- list()\n  for (k in 1:J) {\n    ret_training_regime[[k]] <- data_training[,1] * (yhat_train == k)\n  }\n  ret_training_regime <- do.call(cbind, ret_training_regime)\n  \n  output$hmm_yhat <- yhat_train\n  output$hmm_ret_regime <- ret_training_regime\n  output$hmm_predict_regime <- tail(output$hmm_yhat, 1);\n  \n  \n  ### calculate the risk measures \n  sharpe_training_regime_vol <- SharpeRatio(ret_training_regime)[2,]\n  max_sharpe_regime <- match(max(sharpe_training_regime_vol), sharpe_training_regime_vol)\n  calmar_training_regime <- CalmarRatio(ret_training_regime)\n  max_calmar_regime <- match(max(calmar_training_regime), calmar_training_regime)\n  sortino_training_regime <- SortinoRatio(ret_training_regime)\n  max_sortino_regime <- match(max(sortino_training_regime), sortino_training_regime)\n  output$hmm_ret_regime_annualized <- Return.annualized(ret_training_regime)\n  \n  output$sharpe_ratio <- sharpe_training_regime_vol;\n  output$sharpe_ratio_max_regime <- max_sharpe_regime;\n  output$calmar_ratio <- calmar_training_regime;\n  output$calmar_ratio_max_regime <- max_calmar_regime;\n  output$sortino_ratio <- sortino_training_regime;\n  output$sortino_ratio_max_regime <- max_sortino_regime;\n  \n\n  \n  return(output);\n}\n\n## out of sample test for GMM+HMM\n####################################################################\ngmmhmm <- function(dataset, ret_target, n_start, n_state = 0) {\n  n <- nrow(dataset) \n  ret_s1 <- ret_target * 0;\n  for (i in n_start:(n-1)) {\n    data_training <- dataset[(i - n_start + 1):i,];\n    ## determine whether training dataset is a single serie or multiples\n    n_serie <- ncol(data_training)  \n    \n    #### Using Mixture Model to determine the optimal number of regimes and the settings under \n    #### each regime\n    if (n_state == 0) {\n      mm_model <- Mclust(data_training) }\n    else {\n      mm_model <- Mclust(data_training, G = n_state)}\n    mm_output <- summary(mm_model)\n    \n    #### creating the HMM model\n    J <- mm_output$G\n    print(paste(\"Nr of Regimes \", J))\n    initial <- rep(1/J, J)\n    P <- matrix(rep(1/J, J*J), nrow=J)\n    if (n_serie == 1) {\n      mean <- as.numeric(mm_output$mean)\n      vcv <- as.numeric(mm_output$variance)\n    }\n    else\n    {\n      mean <- list()\n      vcv <- list()\n      for (j in 1:J){\n        mean[[j]] <- mm_output$mean[, j]\n        vcv[[j]] <- mm_output$variance[,,j]\n      }\n    }\n    \n    b <- list()\n    b$mu <- mean\n    b$sigma <- vcv\n    \n    \n    \n    \n    #### training HMM model\n    #### training HMM model\n    if (n_serie == 1) {\n      hmm_model <- hmmspec(init=initial, trans=P, parms.emission = b, dens.emission = dnorm.hsmm)\n      hmm_fitted <- hmmfit(as.numeric(data_training), hmm_model, mstep = mstep.norm)\n    }\n    else {\n      hmm_model <- hmmspec(init=initial, trans=P, parms.emission = b, dens.emission = dmvnorm.hsmm)\n      hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n    }\n    #hmm_model <- hmmspec(init=initial, trans=P, parms.emission = b, dens.emission =dmvnorm.hsmm)\n    #hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n    print(\"hmm fitting\")\n    #### Predict future regime\n    regime <- tail(hmm_fitted$yhat, 1);\n    \n    \n    ############################################################\n    #### In the training set, the regimes and returns\n    yhat_train <- as.xts(hmm_fitted$yhat, order.by = index(data_training), tzone=tzone(data_training))\n    ret_training_regime <- list()\n    for (k in 1:J) {\n      ret_training_regime[[k]] <- data_training[,1] * (yhat_train == k)\n    }\n    ret_training_regime <- do.call(cbind, ret_training_regime)\n    \n    ### calculate the risk measures \n    sharpe_training_regime_vol <- SharpeRatio(ret_training_regime)[1,]\n    max_sharpe_regime <- match(max(sharpe_training_regime_vol), sharpe_training_regime_vol)\n    #calmar_training_regime <- CalmarRatio(ret_training_regime)\n    #max_calmar_regime <- match(max(calmar_training_regime), calmar_training_regime)\n    #sortino_training_regime <- SortinoRatio(ret_training_regime)\n    #max_sortino_regime <- match(max(sortino_training_regime), sortino_training_regime)\n    ret_training_regime <- mean(ret_training_regime)\n    \n    max_order = sort(sharpe_training_regime_vol, index.return=TRUE, decreasing=TRUE)\n    max_order = max_order$ix\n    \n    top_regime1 <- max_order[1];\n    top_regime2 <- max_order[2];\n    \n    ret_avg_regime1 <- ret_training_regime[top_regime1]\n    ret_avg_regime2 <- ret_training_regime[top_regime2]\n    \n    \n    ##################################\n    #signal <- gmm_hmm_strategy(data_training, data_test, ret_target);\n    \n    \n    last_ret <- ret_target[i];\n    next_ret <- ret_target[i+1];\n    \n    #selected_ret <- next_ret * (sharpe_training_regime_vol[regime] > 0)\n    \n    #selected_ret <- next_ret * ((regime == top_regime1 & ret_avg_regime1 > 0) | \n    #                              (regime == top_regime2 & ret_avg_regime2 > 0))\n    #selected_ret <- next_ret * ((regime == top_regime1 & ret_avg_regime1 > 0) )\n    selected_ret <- next_ret * (regime == top_regime1 | regime == top_regime2)\n    ret_s1[i+1] <- selected_ret\n    \n    print(paste(\"target regime = \", top_regime1));\n    print(paste(\"target regime = \", top_regime2));\n    print(paste(\"current regime = \", regime, \": date = \", as.character(index(ret_target[i]))));\n    print(paste(\"prev ret =\", last_ret, \n                \": next ret =\", next_ret, \": selected_ret = \", selected_ret));\n    print(paste(\"cumulative ret=\", sum(ret_s1)))\n    \n    if (i >= (n_start+10)){\n      ret_c <- cbind(ret_s1[(n_start):(i+1)], ret_target[(n_start):(i+1)])\n      charts.PerformanceSummary(ret_c)\n      \n      #save(ret_c, \"ret_c.data\")\n      \n    }\n    print(paste(\"i=\", i))\n    \n  }\n  \n  ret_c <- cbind(ret_s1[n_start:n,], ret_target[n_start:n,])\n  save(ret_c, \"ret_c.data\")\n  charts.PerformanceSummary(ret_c)\n  #rbind(table.AnnualizedReturns(ret_c), maxDrawdown(ret_c), CalmarRatio(ret_c))\n  return(ret_c)\n  \n}\n\ngmmhmm1 <- function(dataset, ret_target, n_start, n_state = 0) {\n  n <- nrow(dataset) \n  ret_s1 <- ret_target * 0;\n  for (i in n_start:n) {\n    data_training <- dataset[(i - n_start + 1):i,];\n    \n    #### Using Mixture Model to determine the optimal number of regimes and the settings under \n    #### each regime\n    if (n_state == 0) {\n      mm_model <- Mclust(data_training) }\n    else {\n      mm_model <- Mclust(data_training, G = n_state)}\n    mm_output <- summary(mm_model)\n    \n    #### creating the HMM model\n    J <- mm_output$G\n    print(paste(\"Nr of Regimes \", J))\n    initial <- rep(1/J, J)\n    P <- matrix(rep(1/J, J*J), nrow=J)\n    mean <- list()\n    vcv <- list()\n    for (j in 1:J){\n      mean[[j]] <- mm_output$mean[, j]\n      vcv[[j]] <- mm_output$variance[,,j]\n    }\n    b <- list()\n    b$mu <- mean\n    b$sigma <- vcv\n    \n    #### training HMM model\n    \n    hmm_model <- hmmspec(init=initial, trans=P, parms.emission = b, dens.emission =dmvnorm.hsmm)\n    hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n    print(\"hmm fitting\")\n    #### Predict future regime\n    regime <- tail(hmm_fitted$yhat, 1);\n    \n    \n    ############################################################\n    #### In the training set, the regimes and returns\n    yhat_train <- as.xts(hmm_fitted$yhat, order.by = index(data_training), tzone=tzone(data_training))\n    ret_training_regime <- list()\n    for (k in 1:J) {\n      ret_training_regime[[k]] <- data_training[,1] * (yhat_train == k)\n    }\n    ret_training_regime <- do.call(cbind, ret_training_regime)\n    \n    ### calculate the risk measures \n    sharpe_training_regime_vol <- SharpeRatio(ret_training_regime)[1,]\n    max_sharpe_regime <- match(max(sharpe_training_regime_vol), sharpe_training_regime_vol)\n    #calmar_training_regime <- CalmarRatio(ret_training_regime)\n    #max_calmar_regime <- match(max(calmar_training_regime), calmar_training_regime)\n    #sortino_training_regime <- SortinoRatio(ret_training_regime)\n    #max_sortino_regime <- match(max(sortino_training_regime), sortino_training_regime)\n    ret_training_regime <- mean(ret_training_regime)\n    \n    max_order = sort(sharpe_training_regime_vol, index.return=TRUE, decreasing=TRUE)\n    max_order = max_order$ix\n    \n    top_regime1 <- max_order[1];\n    top_regime2 <- max_order[2];\n    \n    ret_avg_regime1 <- ret_training_regime[top_regime1]\n    ret_avg_regime2 <- ret_training_regime[top_regime2]\n    \n    \n    ##################################\n    #signal <- gmm_hmm_strategy(data_training, data_test, ret_target);\n    \n    \n    last_ret <- ret_target[i];\n    next_ret <- ret_target[i+1];\n    \n    #selected_ret <- next_ret * (sharpe_training_regime_vol[regime] > 0)\n    \n    #selected_ret <- next_ret * ((regime == top_regime1 & ret_avg_regime1 > 0) | \n    #                              (regime == top_regime2 & ret_avg_regime2 > 0))\n    #selected_ret <- next_ret * ((regime == top_regime1 & ret_avg_regime1 > 0) )\n    \n    #selected_ret <- next_ret * (regime == top_regime1 | regime == top_regime2)\n    selected_ret <- next_ret * (regime == top_regime1)\n    ret_s1[i+1] <- selected_ret\n    \n    print(paste(\"target regime = \", top_regime1));\n    print(paste(\"target regime = \", top_regime2));\n    print(paste(\"current regime = \", regime, \": date = \", as.character(index(ret_target[i]))));\n    print(paste(\"prev ret =\", last_ret, \n                \": next ret =\", next_ret, \": selected_ret = \", selected_ret));\n    print(paste(\"cumulative ret=\", sum(ret_s1)))\n    \n    if (i >= (n_start+10)){\n      ret_c <- cbind(ret_s1[(n_start):(i+1)], ret_target[(n_start):(i+1)])\n      charts.PerformanceSummary(ret_c)\n      \n      #save(ret_c, \"ret_c.data\")\n      \n    }\n    print(paste(\"i=\", i))\n  }\n  \n  ret_c <- cbind(ret_s1[n_start:n,], ret_target[n_start:n,])\n  #rbind(table.AnnualizedReturns(ret_c), maxDrawdown(ret_c), CalmarRatio(ret_c))\n  return(ret_c)\n  \n}\n\n\n\ngmmhmm2 <- function(dataset, ret_target, n_start, n_state = 0) {\n  n <- nrow(dataset) \n  ret_s1 <- ret_target * 0;\n  for (i in n_start:n) {\n    data_training <- dataset[(i - n_start + 1):i,];\n    \n    #### Using Mixture Model to determine the optimal number of regimes and the settings under \n    #### each regime\n    if (n_state == 0) {\n      mm_model <- Mclust(data_training) }\n    else {\n      mm_model <- Mclust(data_training, G = n_state)}\n    mm_output <- summary(mm_model)\n    \n    #### creating the HMM model\n    J <- mm_output$G\n    print(paste(\"Nr of Regimes \", J))\n    initial <- rep(1/J, J)\n    P <- matrix(rep(1/J, J*J), nrow=J)\n    mean <- list()\n    vcv <- list()\n    for (j in 1:J){\n      mean[[j]] <- mm_output$mean[, j]\n      vcv[[j]] <- mm_output$variance[,,j]\n    }\n    b <- list()\n    b$mu <- mean\n    b$sigma <- vcv\n    \n    #### training HMM model\n    \n    hmm_model <- hmmspec(init=initial, trans=P, parms.emission = b, dens.emission =dmvnorm.hsmm)\n    hmm_fitted <- hmmfit(data_training, hmm_model, mstep = mstep.mvnorm)\n    print(\"hmm fitting\")\n    #### Predict future regime\n    regime <- tail(hmm_fitted$yhat, 1);\n    \n    \n    ############################################################\n    #### In the training set, the regimes and returns\n    yhat_train <- as.xts(hmm_fitted$yhat, order.by = index(data_training), tzone=tzone(data_training))\n    ret_training_regime <- list()\n    for (k in 1:J) {\n      ret_training_regime[[k]] <- data_training[,1] * (yhat_train == k)\n    }\n    ret_training_regime <- do.call(cbind, ret_training_regime)\n    \n    ### calculate the risk measures \n    sharpe_training_regime_vol <- SharpeRatio(ret_training_regime)[1,]\n    max_sharpe_regime <- match(max(sharpe_training_regime_vol), sharpe_training_regime_vol)\n    #calmar_training_regime <- CalmarRatio(ret_training_regime)\n    #max_calmar_regime <- match(max(calmar_training_regime), calmar_training_regime)\n    #sortino_training_regime <- SortinoRatio(ret_training_regime)\n    #max_sortino_regime <- match(max(sortino_training_regime), sortino_training_regime)\n    ret_training_regime <- mean.geometric(ret_training_regime)\n    \n    max_order = sort(sharpe_training_regime_vol, index.return=TRUE, decreasing=TRUE)\n    max_order = max_order$ix\n    \n    top_regime1 <- max_order[1];\n    top_regime2 <- max_order[2];\n    \n    ret_avg_regime1 <- ret_training_regime[top_regime1]\n    ret_avg_regime2 <- ret_training_regime[top_regime2]\n    \n    \n    ##################################\n    #signal <- gmm_hmm_strategy(data_training, data_test, ret_target);\n    \n    \n    last_ret <- ret_target[i];\n    next_ret <- ret_target[i+1];\n    \n    #selected_ret <- next_ret * (sharpe_training_regime_vol[regime] > 0)\n    \n    selected_ret <- next_ret * ((regime == top_regime1 & ret_avg_regime1 > 0) | \n                                  (regime == top_regime2 & ret_avg_regime2 > 0))\n    #selected_ret <- next_ret * ((regime == top_regime1 & ret_avg_regime1 > 0) )\n    \n    #selected_ret <- next_ret * (regime == top_regime1 | regime == top_regime2)\n    #selected_ret <- next_ret * (regime == top_regime1)\n    ret_s1[i+1] <- selected_ret\n    \n    print(paste(\"target regime = \", top_regime1));\n    print(paste(\"target regime = \", top_regime2));\n    print(paste(\"current regime = \", regime, \": date = \", as.character(index(ret_target[i]))));\n    print(paste(\"prev ret =\", last_ret, \n                \": next ret =\", next_ret, \": selected_ret = \", selected_ret));\n    print(paste(\"cumulative ret=\", sum(ret_s1)))\n    \n    if (i >= (n_start+10)){\n      ret_c <- cbind(ret_s1[(n_start):(i+1)], ret_target[(n_start):(i+1)])\n      charts.PerformanceSummary(ret_c)\n      \n      #save(ret_c, \"ret_c.data\")\n      \n    }\n    print(paste(\"i=\", i))\n  }\n  \n  ret_c <- cbind(ret_s1[n_start:n,], ret_target[n_start:n,])\n  #rbind(table.AnnualizedReturns(ret_c), maxDrawdown(ret_c), CalmarRatio(ret_c))\n  return(ret_c)\n  \n}\n\n\nregime_gmmhmm <- function(price_data, target_index = 1, nstate = 0) {\n  prices <- na.omit(price_data);\n  ret <- ROC(prices, n = 1, type = \"continuous\")\n  #ret <- Return.calculate(prices[endpoints(prices, on=period)], method = \"log\")\n  ret <- na.omit(ret)\n  gmm <- gmm_training(ret, nstate) # GMM 捕捉指定数量的市场状态， 并生成相应的参数；\n  hmm <- hmm_training(gmm, data_training = ret, ret_target = ret[, target_index])\n  return(hmm)\n  \n}\n\n",
    "created" : 1446516350251.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "19|51|66|0|\n75|74|111|0|\n115|47|136|0|\n200|80|236|0|\n238|44|304|0|\n308|63|434|0|\n436|64|540|0|\n544|64|648|0|\n",
    "hash" : "1149660735",
    "id" : "E7E6A196",
    "lastKnownWriteTime" : 1446531750,
    "path" : "~/Documents/Research_Projects/Trading_Strategies/HMM_Timing/gmmhmm.R",
    "project_path" : "gmmhmm.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}