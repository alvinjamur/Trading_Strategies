{
    "contents" : "source(\"gmmhmm.R\")\nlibrary(quantmod)\n\n## 测试中证500\n########################################################################\n## 0. 读取指数数据\n#data <- read.csv(\"data/NAV_5ETFs_updated.csv\")\n#benchmark <- na.omit(as.xts(data[, 2], order.by=strptime(data[,1], format=\"%Y/%m/%d\", tz=\"\")))\n#benchmark_ret <- na.omit(Return.calculate(benchmark, method = \"discrete\"))\n\n\n############################\n## 5 mins\ndata <- read.csv(\"data/2.csv\", sep = \";\")\nbenchmark <- na.omit(as.xts(data[, 2], order.by=strptime(data[,1], format=\"%Y/%m/%d %H:%M\", tz=\"\")))\n\n\n######################\n## 30 mins\n#data <- read.csv(\"data/4.csv\", sep = \";\")\n#benchmark <- na.omit(as.xts(data[, 2], order.by=strptime(data[,1], format=\"%y/%m/%d %H:%M\", tz=\"\")))\n\n#########################\n## 股指期货5min\n#data <- read.csv(\"data/Future_5min.csv\")\n#benchmark <- na.omit(as.xts(data[, 2], order.by=strptime(data[,1], format=\"%Y/%m/%d %H:%M\", tz=\"\")))\n\n#############################\n## SPY\n#library(Quandl)\n#data <- Quandl('CURRFX/EURUSD', type='xts',collapse = 'daily')\n#benchmark <- data[,1]\n\nbenchmark_ret <- (benchmark / lag(benchmark, 1)) - 1\nbenchmark_ret <- na.omit(benchmark_ret)\n\n#benchmark_ret <- benchmark_ret[3000:4000]\n\n\n\nsignal <- (benchmark_ret > 0)* 1\n\n\ngeneratePatterns <- function(testing_ret) {\n  signal <- (benchmark_ret > 0)*1\n  patterns <- signal * 0\n  n = 3\n  \n  for (i in 1:n) {\n    patterns <- patterns + lag(signal, n-i) * 2^(n-i)\n  }\n  output <- list()\n  output$signal <- signal\n  output$patterns <- patterns\n  return(output)\n}\n\ncategorizeReturns <- function(rets, signal, patterns, n) {\n  total_nr_patterns <- 2^n\n  \n  for (i in 1:total_nr_patterns) {\n    index_group <- signal[patterns == ]\n  }\n  \n}\n\ngroups <- list()\nsignals <- list()\nrets_group <- list()\nsharpes_group <- list()\ncount_group <- list()\naccuracy_group <- list()\nfor (k in 1:(2^n )) {\n  groups[[k]] <- signal[patterns == (k-1)]\n  #groups[[k]] <- signal[patterns == k]\n  signals[[k]] <- na.omit(groups[[k]])\n  rets_group[[k]] <- benchmark_ret[index(signals[[k]])]\n  sharpes_group[[k]] <- mean(rets_group[[k]]) / as.numeric(cov(rets_group[[k]]))\n  count_group[[k]] <- length(signals[[k]])\n  accuracy_group[[k]] <- sum(signals[[k]]) / count_group[[k]]\n}\ngroups <- do.call(cbind, groups)\ngroups[is.na(groups)] <- 0\nsharpes_group <- do.call(rbind, sharpes_group)\ncount_group <- do.call(rbind, count_group)\naccuracy_group <- do.call(rbind, accuracy_group)\n\ncolnames(groups) <- c(1:(2^n))\ncolMeans(groups)\nsharpes_group\n#####\nhead(cbind(signal, patterns, benchmark_ret), 64)\nplot(cumprod(1+rets_group[[16]]))\n\n\nrets <- rets_group[[1]]\nfor (i in 2:(2^n)) {\n  rets <- cbind(rets, rets_group[[i]])\n}\nrets <- cbind(rets, benchmark_ret )\nrets[is.na(rets)] <- 0\n\n\nret_target <- rets[,1]\ntzone(ret_target) <- Sys.getenv(\"TZ\")\ncharts.PerformanceSummary(rets[,c(2)])\n\nrets_positive <- rets[, 1] * 0;\ntzone(rets_positive) <- Sys.getenv(\"TZ\")\nrets_negative <- rets_positive\nfor (i in 1:(2^n)) {\n  if (sharpes_group[i] > 0)\n    rets_positive <- rets_positive + rets[, i]\n  if (sharpes_group[i] < 0)\n    rets_negative <- rets_negative + rets[,i]\n}\ncharts.PerformanceSummary(cbind(rets_positive - rets_negative, rets_positive, -rets_negative, benchmark_ret))\n\ncbind(accuracy_group, sharpes_group)\n\n",
    "created" : 1445927232142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "799147305",
    "id" : "E09B2D99",
    "lastKnownWriteTime" : 1445927251,
    "path" : "~/Documents/Research_Projects/Trading_Strategies/SLM/slm.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}